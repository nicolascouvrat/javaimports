package com.nikodoko.javaimports.stdlib.internal;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.collect.Iterables;
import com.google.common.io.Files;
import com.google.common.reflect.ClassPath;
import com.google.common.reflect.ClassPath.ResourceInfo;
import com.google.googlejavaformat.java.Formatter;
import com.google.googlejavaformat.java.FormatterException;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GenerateStdlib {
  private static final Path apiPath = Paths.get("api");
  private static final ClassLoader loader = GenerateStdlib.class.getClassLoader();
  private static final Pattern apiFileNamePattern = Pattern.compile("java-(?<version>\\d+)\\.txt");
  private static final Pattern importablePattern =
      Pattern.compile("pkg (?<pkg>\\S+) class (?<class>\\S+)(?:, static (?<identifier>\\w+))?");
  private static final String prefix =
      "core/src/main/java/com/nikodoko/javaimports/stdlib/internal/";
  // Adjust to control the output file size (and avoid StackOverflow errors when compiling)
  private static final int MAX_CHUNK_SIZE = 300;

  private static class Importable {
    String pkg = "";
    String name = "";
    boolean isStatic;

    public void output(PrintWriter out) {
      out.printf("newImport(\"%s.%s\",%b)", pkg, name, isStatic);
    }
  }

  private static interface Exportable {
    String filename();

    String directory();

    void output(PrintWriter out);
  }

  private static class JavaApi implements Exportable {
    static String FILENAME_TEMPLATE = "Java%sStdlib";
    static String DIRECTORY_TEMPLATE =
        "core/src/main/java/com/nikodoko/javaimports/stdlib/internal/api/v%s/";

    String version;
    List<JavaApiChunk> chunks = new ArrayList<>();

    public String filename() {
      return String.format(FILENAME_TEMPLATE, version);
    }

    public String directory() {
      return String.format(DIRECTORY_TEMPLATE, version);
    }

    private String[] header() {
      return new String[] {
        "// Code generated by GenerateStdlib.java. DO NOT EDIT.",
        String.format("package com.nikodoko.javaimports.stdlib.internal.api.v%s;", version),
        "import com.nikodoko.javaimports.common.Import;",
        "import com.nikodoko.javaimports.common.Identifier;",
        "import com.nikodoko.javaimports.stdlib.internal.Stdlib;",
        String.format("public class %s implements Stdlib {", filename()),
        "public Import[] getClassesFor(Identifier identifier) {",
        "Import[] classes = null;",
      };
    }

    private String[] footer() {
      return new String[] {
        "return null;", "}", "}",
      };
    }

    public void output(PrintWriter out) {
      for (String line : header()) {
        out.println(line);
      }

      for (JavaApiChunk chunk : chunks) {
        out.printf("classes = %s.CLASSES.get(identifier);\n", chunk.filename());
        out.println("if (classes != null) {");
        out.println("return classes;");
        out.println("}");
      }

      for (String line : footer()) {
        out.println(line);
      }
    }
  }

  private static class JavaApiChunk implements Exportable {
    static String FILENAME_TEMPLATE = "Java%sStdlibChunk%d";
    static String DIRECTORY_TEMPLATE =
        "core/src/main/java/com/nikodoko/javaimports/stdlib/internal/api/v%s/";

    String version;
    int number;
    Map<String, List<Importable>> importables = new HashMap<>();

    public String filename() {
      return String.format(FILENAME_TEMPLATE, version, number);
    }

    public String directory() {
      return String.format(DIRECTORY_TEMPLATE, version);
    }

    private String[] header() {
      return new String[] {
        "// Code generated by GenerateStdlib.java. DO NOT EDIT.",
        String.format("package com.nikodoko.javaimports.stdlib.internal.api.v%s;", version),
        "import static com.nikodoko.javaimports.stdlib.internal.Stdlib.newImport;",
        "import com.google.common.collect.ImmutableMap;",
        "import com.nikodoko.javaimports.common.Import;",
        "import com.nikodoko.javaimports.common.Identifier;",
        "import java.util.Map;",
        String.format("public class %s {", filename()),
        "static final Map<Identifier, Import[]> CLASSES = new ImmutableMap.Builder<Identifier,"
            + " Import[]>()",
      };
    }

    private String[] footer() {
      return new String[] {
        ".build();", "}",
      };
    }

    public void output(PrintWriter out) {
      for (String line : header()) {
        out.println(line);
      }

      for (Map.Entry<String, List<Importable>> importablesOfName : importables.entrySet()) {
        out.printf(".put(new Identifier(\"%s\"), new Import[] {", importablesOfName.getKey());
        for (Importable i : importablesOfName.getValue()) {
          i.output(out);
          out.print(",");
        }
        out.print("})\n");
      }

      for (String line : footer()) {
        out.println(line);
      }
    }
  }

  public static void main(String[] args) {
    try {
      List<JavaApi> apis = loadApis();
      for (JavaApi api : apis) {
        export(api);
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private static List<JavaApi> loadApis() throws IOException {
    List<JavaApi> apis = new ArrayList<>();
    for (ResourceInfo resourceInfo : ClassPath.from(loader).getResources()) {
      Path resourcePath = Paths.get(resourceInfo.getResourceName());
      Matcher m = apiFileNamePattern.matcher(resourcePath.getFileName().toString());
      if (m.matches()) {
        apis.add(loadApi(m.group("version"), resourceInfo.getResourceName()));
      }
    }

    return apis;
  }

  private static JavaApi loadApi(String version, String path) throws IOException {
    JavaApi api = new JavaApi();
    api.version = version;
    try (InputStream stream = loader.getResourceAsStream(path)) {
      BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
      api.chunks = split(version, loadImportables(reader));
    }

    return api;
  }

  private static List<JavaApiChunk> split(
      String version, Map<String, List<Importable>> importables) {
    List<JavaApiChunk> chunks = new ArrayList<>();
    Iterable<List<String>> identifiersChunks =
        Iterables.partition(importables.keySet(), MAX_CHUNK_SIZE);
    int i = 0;
    for (List<String> identifiersChunk : identifiersChunks) {
      JavaApiChunk chunk = new JavaApiChunk();
      chunk.version = version;
      chunk.number = i++;
      for (String identifier : identifiersChunk) {
        chunk.importables.put(identifier, importables.get(identifier));
      }

      chunks.add(chunk);
    }

    return chunks;
  }

  private static Map<String, List<Importable>> loadImportables(BufferedReader reader)
      throws IOException {
    Map<String, List<Importable>> importables = new HashMap<>();
    String line;
    while ((line = reader.readLine()) != null) {
      Matcher m = importablePattern.matcher(line);
      if (!m.matches()) {
        continue;
      }

      Importable importable = loadImportable(m);
      List<Importable> importablesOfSameName = importables.get(importable.name);
      if (importablesOfSameName == null) {
        importablesOfSameName = new ArrayList<>();
      }

      importablesOfSameName.add(importable);
      importables.put(importable.name, importablesOfSameName);
    }

    return importables;
  }

  private static Importable loadImportable(Matcher match) {
    Importable importable = new Importable();
    String pkg = match.group("pkg");
    String className = match.group("class");
    String identifier = match.group("identifier");
    if (identifier == null) {
      importable.isStatic = false;
      importable.pkg = pkg;
      importable.name = className;
      return importable;
    }

    // in the case of a static import, we want to be able to address it by its identifier and not
    // className.identifier
    importable.isStatic = true;
    importable.pkg = String.join(".", pkg, className);
    importable.name = identifier;
    return importable;
  }

  private static void export(JavaApi api) throws FormatterException, IOException {
    for (JavaApiChunk chunk : api.chunks) {
      exportToFile(chunk);
    }

    exportToFile(api);
  }

  private static void exportToFile(Exportable exportable) throws FormatterException, IOException {
    StringWriter writer = new StringWriter();
    PrintWriter out = new PrintWriter(writer);
    exportable.output(out);
    String formatted = new Formatter().formatSourceAndFixImports(writer.toString());
    File f = new File(exportable.directory() + exportable.filename() + ".java");
    Files.createParentDirs(f);
    Files.asCharSink(f, UTF_8).write(formatted);
  }
}
