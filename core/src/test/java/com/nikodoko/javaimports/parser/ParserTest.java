package com.nikodoko.javaimports.parser;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.nikodoko.javaimports.common.CommonTestUtil.aSelector;
import static com.nikodoko.javaimports.common.CommonTestUtil.anImport;
import static com.nikodoko.javaimports.common.CommonTestUtil.someIdentifiers;
import static org.junit.Assert.fail;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;
import com.google.common.truth.StreamSubject;
import com.nikodoko.javaimports.ImporterException;
import com.nikodoko.javaimports.common.ClassEntity;
import com.nikodoko.javaimports.common.Identifier;
import com.nikodoko.javaimports.common.Superclass;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Set;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

public class ParserTest {
  static Object[][][] CASES = {
    {
      {"anonymousClass"},
      {
        "package com.pkg.test;",
        "class ATest {",
        "  static class Parent {}",
        "  public void main() {",
        "    var a = new Parent() {",
        "        @Override",
        "        void f() {}",
        "    };",
        "  }",
        "}",
      },
      {"Override"},
      {
        ClassEntity.named(aSelector("ATest")).declaring(someIdentifiers("Parent", "main")).build(),
        ClassEntity.named(aSelector("Parent")).build(),
        ClassEntity.anonymous()
            .declaring(someIdentifiers("f"))
            .extending(Superclass.unresolved(aSelector("Parent")))
            .build()
      },
    },
    {
      {"anonymousEnum"},
      {
        "package com.pkg.test;",
        "enum MyEnum {",
        "  ENUM_VALUE {",
        "    public void func(int param) {",
        "      return 42;",
        "    }",
        "  };",
        "}",
      },
      {},
      {
        ClassEntity.named(aSelector("MyEnum"))
            .declaring(someIdentifiers("ENUM_VALUE"))
            .extending(Superclass.resolved(anImport("java.lang.Enum")))
            .build(),
        ClassEntity.anonymous()
            .declaring(someIdentifiers("func"))
            .extending(Superclass.unresolved(aSelector("MyEnum")))
            .build()
      },
    },
    {
      {"multipleTopLevelClassesInSameFile"},
      {
        "package com.pkg.test;",
        "class ATest {",
        "  public void g() {",
        "    int c = f(b);",
        "  }",
        "  public int f(int a) {",
        "    int b = 2;",
        "    return a + b;",
        "  }",
        "}",
        "class AnotherTest {",
        "  public void g() {",
        "    int c = f(d);",
        "  }",
        "  public int f(int a) {",
        "    int b = 2;",
        "    return a + b;",
        "  }",
        "}",
      },
      {"b", "d"},
      {
        ClassEntity.named(aSelector("ATest")).declaring(someIdentifiers("g", "f")).build(),
        ClassEntity.named(aSelector("AnotherTest")).declaring(someIdentifiers("g", "f")).build()
      },
    },
    {
      {"enum"},
      {
        "package com.pkg.test;", //
        "enum TestEnum {",
        "  VALUE_1, VALUE_2;",
        "}",
      },
      {},
      {
        ClassEntity.named(aSelector("TestEnum"))
            .declaring(someIdentifiers("VALUE_1", "VALUE_2"))
            .extending(Superclass.resolved(anImport("java.lang.Enum")))
            .build()
      },
    },
    {
      {"methodBodyAndArguments"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void g() {",
        "    int c = f(b);",
        "  }",
        "  public int f(int a) {",
        "    int b = 2;",
        "    return a + b;",
        "  }",
        "}",
      },
      {"b"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("g", "f")).build()},
    },
    {
      {"forLoop"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    for (int i = 0; i < 10; i ++) {",
        "      int b = 2;",
        "      staticFunction(i + b);",
        "    }",
        "    int var = i + b;",
        "    boolean[] c = {true, false};",
        "    for (boolean d : c) {",
        "      boolean e = d;",
        "    }",
        "    boolean f = e || d;",
        "  }",
        "}",
      },
      {"staticFunction", "i", "b", "e", "d"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"ifBlock"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    if (true) {",
        "      int a = 2;",
        "      int b = 3;",
        "    } else {",
        "      int c = a;",
        "    }",
        "    int var = b + c;",
        "  }",
        "}",
      },
      {"a", "b", "c"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"whileLoop"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    while (true) {",
        "      int a = 2;",
        "    }",
        "    int var = a;",
        "  }",
        "}",
      },
      {"a"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"synchronizedBlock"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    synchronized (this) {",
        "      int a = 2;",
        "    }",
        "    int var = a;",
        "  }",
        "}",
      },
      // The parser does not know about "this" and sees it as an unresolved symbol
      {"this", "a"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"doWhileLoop"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    do {",
        "      int a = 2;",
        "    } while (true);",
        "    int var = a;",
        "  }",
        "}",
      },
      {"a"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"annotation"},
      {
        "package com.pkg.test;",
        "class Test {", //
        "  @SomeAnnotation",
        "  public void f() {",
        "    return;",
        "  }",
        "}",
      },
      {"SomeAnnotation"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"lambda"},
      {
        "package com.pkg.test;",
        "class Test {", //
        "  public void f() {",
        "    int a = 1;",
        "    BiFunction<Integer, Integer, Integer> f = (b, c) -> a + b + c;",
        "    int d = f.apply(2, 3) + b;",
        "  }",
        "}",
      },
      {"b", "Integer", "BiFunction"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"switchBlock"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    int a = 2;",
        "    switch (a) {",
        "    case 1:",
        "      int b = 2;",
        "      break;",
        "    case 2:",
        "      int c = b;",
        "      break;",
        "    }",
        "    int var = c;",
        "  }",
        "}",
      },
      {"c"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"java14Switch"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    int a = 2;",
        "    int b = switch (a) {",
        "    case 1 -> {",
        "      int c = 2;",
        "      yield c;",
        "    }",
        "    case 2 -> {",
        "      int d = c;",
        "      yield d;",
        "    }",
        "    default -> 0;",
        "    };",
        "  }",
        "}",
      },
      {"c"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      // Because "The scope of an enum constant C declared in an enum type T is the body of T, and
      // any case label of a switch statement whose expression is of enum type T" (see
      // https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.3), we should ignore
      // unknown symbols in case labels to avoid importing things we don't want to import.
      {"switchIgnoreCaseLabels"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    switch (a) {",
        "    case b:",
        "      int c = 2;",
        "      break;",
        "    }",
        "  }",
        "}",
      },
      {"a"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"java14SwitchIgnoreCaseLabels"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    int r = switch (a) {",
        "    case b -> {",
        "      int c = 2;",
        "      yield c;",
        "    }",
        "    default -> 0;",
        "    };",
        "  }",
        "}",
      },
      {"a"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"tryCatchFinally"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    try {",
        "      int a = 1;",
        "    } catch (SomeException e) {",
        "      int b = e.getErrorCode();",
        "    } catch (Exception e) {",
        "      int c = a;",
        "    } finally {",
        "      int d = b;",
        "    }",
        "    int var = c + e;",
        "  }",
        "}",
      },
      {"SomeException", "Exception", "a", "b", "c", "e"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"tryWithResource"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  public void f() {",
        "    try (int r = 1) {",
        "      int a = 1 + r;",
        "    } catch (SomeException e) {",
        "      int b = e.getErrorCode();",
        "    } catch (Exception e) {",
        "      int c = a + r;",
        "    } finally {",
        "      int d = b + r;",
        "    }",
        "    int var = c + e + r;",
        "  }",
        "}",
      },
      {"SomeException", "Exception", "a", "b", "c", "e", "r"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"extendsClauseStartingWithLowercaseIsConsideredResolved"},
      {
        "package com.pkg.test;",
        "class Test extends com.my.pkg.Child {", //
        "}",
      },
      {},
      {
        ClassEntity.named(aSelector("Test"))
            .extending(Superclass.resolved(anImport("com.my.pkg.Child")))
            .build()
      },
    },
    {
      {"localInheritence"},
      {
        "package com.pkg.test;",
        "class Test {",
        "  static class OtherChild extends Child {",
        "    public private void m() {",
        "      int c = n(f() + g(0));",
        "    }",
        "  }",
        "  static class Child extends Parent {",
        "    void f() {",
        "      int c = g(a) + h(b);",
        "    }",
        "  }",
        "  static class Parent {",
        "    protected int a = 0;",
        "    public int p(int x) {",
        "      return x;",
        "    }",
        "    public int g(int x) {",
        "      int b = 5;",
        "      return x;",
        "    }",
        "    int h(int x) {",
        "      return x;",
        "    }",
        "  }",
        "}",
      },
      {"b", "n"},
      {
        ClassEntity.named(aSelector("Test"))
            .declaring(someIdentifiers("OtherChild", "Child", "Parent"))
            .build(),
        ClassEntity.named(aSelector("OtherChild"))
            .extending(Superclass.unresolved(aSelector("Child")))
            .declaring(someIdentifiers("m"))
            .build(),
        ClassEntity.named(aSelector("Child"))
            .extending(Superclass.unresolved(aSelector("Parent")))
            .declaring(someIdentifiers("f"))
            .build(),
        ClassEntity.named(aSelector("Parent"))
            .declaring(someIdentifiers("a", "p", "g", "h"))
            .build()
      },
    },
    {
      {"annotationParametersVariableNotImported"},
      {
        "package com.pkg.test;",
        "@Annotation(a=\"value\")",
        "class Test {",
        "  @Function",
        "  public void f() {",
        "    return 0;",
        "  }",
        "}",
      },
      {"Annotation", "Function"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"annotationParametersExpressionImported"},
      {
        "package com.pkg.test;",
        "@Annotation(a=b, c=d)",
        "class Test {",
        "  @Function",
        "  public void f() {",
        "    return 0;",
        "  }",
        "}",
      },
      {"Annotation", "Function", "b", "d"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"annotationParametersIdentifierImported"},
      {
        "package com.pkg.test;",
        "@Annotation(b)",
        "class Test {",
        "  @Function",
        "  public void f() {",
        "    return 0;",
        "  }",
        "}",
      },
      {"Annotation", "Function", "b"},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f")).build()},
    },
    {
      {"typeParameters"},
      {
        "package com.pkg.test;",
        "class Test<R> {",
        "  public static <T> T f(T t) {",
        "    R var = null;",
        "    return t;",
        "  }",
        "}",
      },
      {},
      {ClassEntity.named(aSelector("Test")).declaring(someIdentifiers("f", "R")).build()},
    },
    {
      {"realisticFile"},
      {
        "/*",
        " * Copyright (C) 2007 The Guava Authors",
        " *",
        " * Licensed under the Apache License, Version 2.0 (the \"License\");",
        " * you may not use this file except in compliance with the License.",
        " * You may obtain a copy of the License at",
        " *",
        " *",
        " * Unless required by applicable law or agreed to in writing, software",
        " * distributed under the License is distributed on an \"AS IS\" BASIS,",
        " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        " * See the License for the specific language governing permissions and",
        " * limitations under the License.",
        " */",
        "",
        "package com.google.common.collect;",
        "",
        "import static com.google.common.base.Preconditions.checkArgument;",
        "import static com.google.common.base.Preconditions.checkNotNull;",
        "import static com.google.common.collect.CollectPreconditions.checkNonnegative;",
        "",
        "import com.google.common.annotations.Beta;",
        "import com.google.common.annotations.GwtCompatible;",
        "import com.google.common.annotations.VisibleForTesting;",
        "import com.google.common.math.IntMath;",
        "import com.google.common.primitives.Ints;",
        "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
        "import com.google.errorprone.annotations.concurrent.LazyInit;",
        "import com.google.j2objc.annotations.RetainedWith;",
        "import java.io.Serializable;",
        "import java.math.RoundingMode;",
        "import java.util.Arrays;",
        "import java.util.Collection;",
        "import java.util.Collections;",
        "import java.util.EnumSet;",
        "import java.util.Iterator;",
        "import java.util.Set;",
        "import java.util.SortedSet;",
        "import java.util.Spliterator;",
        "import java.util.function.Consumer;",
        "import java.util.stream.Collector;",
        "import org.checkerframework.checker.nullness.qual.Nullable;",
        "",
        "@GwtCompatible(serializable = true, emulated = true)",
        "public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E> {",
        "  static final int SPLITERATOR_CHARACTERISTICS =",
        "      ImmutableCollection.SPLITERATOR_CHARACTERISTICS | Spliterator.DISTINCT;",
        "",
        "  public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {",
        "    return CollectCollectors.toImmutableSet();",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> of() {",
        "    return (ImmutableSet<E>) RegularImmutableSet.EMPTY;",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> of(E element) {",
        "    return new SingletonImmutableSet<E>(element);",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> of(E e1, E e2) {",
        "    return construct(2, 2, e1, e2);",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> of(E e1, E e2, E e3) {",
        "    return construct(3, 3, e1, e2, e3);",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4) {",
        "    return construct(4, 4, e1, e2, e3, e4);",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5) {",
        "    return construct(5, 5, e1, e2, e3, e4, e5);",
        "  }",
        "",
        "  @SafeVarargs",
        "  public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... others) {",
        "    checkArgument(",
        "        others.length <= Integer.MAX_VALUE - 6, \"the total number of elements must fit"
            + " in an int\");",
        "    final int paramCount = 6;",
        "    Object[] elements = new Object[paramCount + others.length];",
        "    elements[0] = e1;",
        "    elements[1] = e2;",
        "    elements[2] = e3;",
        "    elements[3] = e4;",
        "    elements[4] = e5;",
        "    elements[5] = e6;",
        "    System.arraycopy(others, 0, elements, paramCount, others.length);",
        "    return construct(elements.length, elements.length, elements);",
        "  }",
        "",
        "  private static <E> ImmutableSet<E> constructUnknownDuplication(int n, Object..."
            + " elements) {",
        "    return construct(",
        "        n,",
        "        Math.max(",
        "            ImmutableCollection.Builder.DEFAULT_INITIAL_CAPACITY,",
        "            IntMath.sqrt(n, RoundingMode.CEILING)),",
        "        elements);",
        "  }",
        "",
        "  private static <E> ImmutableSet<E> construct(int n, int expectedSize, Object..."
            + " elements) {",
        "    switch (n) {",
        "      case 0:",
        "        return of();",
        "      case 1:",
        "        E elem = (E) elements[0];",
        "        return of(elem);",
        "      default:",
        "        SetBuilderImpl<E> builder = new RegularSetBuilderImpl<E>(expectedSize);",
        "        for (int i = 0; i < n; i++) {",
        "          @SuppressWarnings(\"unchecked\")",
        "          E e = (E) checkNotNull(elements[i]);",
        "          builder = builder.add(e);",
        "        }",
        "        return builder.review().build();",
        "    }",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {",
        "    if (elements instanceof ImmutableSet && !(elements instanceof SortedSet)) {",
        "      ImmutableSet<E> set = (ImmutableSet<E>) elements;",
        "      if (!set.isPartialView()) {",
        "        return set;",
        "      }",
        "    } else if (elements instanceof EnumSet) {",
        "      return copyOfEnumSet((EnumSet) elements);",
        "    }",
        "    Object[] array = elements.toArray();",
        "    if (elements instanceof Set) {",
        "      return construct(array.length, array.length, array);",
        "    } else {",
        "      return constructUnknownDuplication(array.length, array);",
        "    }",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> copyOf(Iterable<? extends E> elements) {",
        "    return (elements instanceof Collection)",
        "        ? copyOf((Collection<? extends E>) elements)",
        "        : copyOf(elements.iterator());",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> copyOf(Iterator<? extends E> elements) {",
        "    if (!elements.hasNext()) {",
        "      return of();",
        "    }",
        "    E first = elements.next();",
        "    if (!elements.hasNext()) {",
        "      return of(first);",
        "    } else {",
        "      return new ImmutableSet.Builder<E>().add(first).addAll(elements).build();",
        "    }",
        "  }",
        "",
        "  public static <E> ImmutableSet<E> copyOf(E[] elements) {",
        "    switch (elements.length) {",
        "      case 0:",
        "        return of();",
        "      case 1:",
        "        return of(elements[0]);",
        "      default:",
        "        return constructUnknownDuplication(elements.length, elements.clone());",
        "    }",
        "  }",
        "",
        "  private static ImmutableSet copyOfEnumSet(EnumSet enumSet) {",
        "    return ImmutableEnumSet.asImmutable(EnumSet.copyOf(enumSet));",
        "  }",
        "",
        "  ImmutableSet() {}",
        "",
        "  boolean isHashCodeFast() {",
        "    return false;",
        "  }",
        "",
        "  @Override",
        "  public boolean equals(@Nullable Object object) {",
        "    if (object == this) {",
        "      return true;",
        "    } else if (object instanceof ImmutableSet",
        "        && isHashCodeFast()",
        "        && ((ImmutableSet<?>) object).isHashCodeFast()",
        "        && hashCode() != object.hashCode()) {",
        "      return false;",
        "    }",
        "    return Sets.equalsImpl(this, object);",
        "  }",
        "",
        "  @Override",
        "  public int hashCode() {",
        "    return Sets.hashCodeImpl(this);",
        "  }",
        "",
        "  @Override",
        "  public abstract UnmodifiableIterator<E> iterator();",
        "",
        "  @LazyInit @RetainedWith private transient @Nullable ImmutableList<E> asList;",
        "",
        "  @Override",
        "  public ImmutableList<E> asList() {",
        "    ImmutableList<E> result = asList;",
        "    return (result == null) ? asList = createAsList() : result;",
        "  }",
        "",
        "  ImmutableList<E> createAsList() {",
        "    return new RegularImmutableAsList<E>(this, toArray());",
        "  }",
        "",
        "  abstract static class Indexed<E> extends ImmutableSet<E> {",
        "    abstract E get(int index);",
        "",
        "    @Override",
        "    public UnmodifiableIterator<E> iterator() {",
        "      return asList().iterator();",
        "    }",
        "",
        "    @Override",
        "    public Spliterator<E> spliterator() {",
        "      return CollectSpliterators.indexed(size(), SPLITERATOR_CHARACTERISTICS, this::get);",
        "    }",
        "",
        "    @Override",
        "    public void forEach(Consumer<? super E> consumer) {",
        "      checkNotNull(consumer);",
        "      int n = size();",
        "      for (int i = 0; i < n; i++) {",
        "        consumer.accept(get(i));",
        "      }",
        "    }",
        "",
        "    @Override",
        "    int copyIntoArray(Object[] dst, int offset) {",
        "      return asList().copyIntoArray(dst, offset);",
        "    }",
        "",
        "    @Override",
        "    ImmutableList<E> createAsList() {",
        "      return new ImmutableAsList<E>() {",
        "        @Override",
        "        public E get(int index) {",
        "          return Indexed.this.get(index);",
        "        }",
        "",
        "        @Override",
        "        Indexed<E> delegateCollection() {",
        "          return Indexed.this;",
        "        }",
        "      };",
        "    }",
        "  }",
        "",
        "  private static class SerializedForm implements Serializable {",
        "    final Object[] elements;",
        "",
        "    SerializedForm(Object[] elements) {",
        "      this.elements = elements;",
        "    }",
        "",
        "    Object readResolve() {",
        "      return copyOf(elements);",
        "    }",
        "",
        "    private static final long serialVersionUID = 0;",
        "  }",
        "",
        "  @Override",
        "  Object writeReplace() {",
        "    return new SerializedForm(toArray());",
        "  }",
        "",
        "  public static <E> Builder<E> builder() {",
        "    return new Builder<E>();",
        "  }",
        "",
        "  @Beta",
        "  public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {",
        "    checkNonnegative(expectedSize, \"expectedSize\");",
        "    return new Builder<E>(expectedSize);",
        "  }",
        "",
        "  static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n) {",
        "    Object[] hashTable = new Object[newTableSize];",
        "    int mask = hashTable.length - 1;",
        "    for (int i = 0; i < n; i++) {",
        "      Object e = elements[i];",
        "      int j0 = Hashing.smear(e.hashCode());",
        "      for (int j = j0; ; j++) {",
        "        int index = j & mask;",
        "        if (hashTable[index] == null) {",
        "          hashTable[index] = e;",
        "          break;",
        "        }",
        "      }",
        "    }",
        "    return hashTable;",
        "  }",
        "",
        "  public static class Builder<E> extends ImmutableCollection.Builder<E> {",
        "    private SetBuilderImpl<E> impl;",
        "    boolean forceCopy;",
        "",
        "    public Builder() {",
        "      this(DEFAULT_INITIAL_CAPACITY);",
        "    }",
        "",
        "    Builder(int capacity) {",
        "      impl = new RegularSetBuilderImpl<E>(capacity);",
        "    }",
        "",
        "    Builder(@SuppressWarnings(\"unused\") boolean subclass) {",
        "    }",
        "",
        "    @VisibleForTesting",
        "    void forceJdk() {",
        "      this.impl = new JdkBackedSetBuilderImpl<E>(impl);",
        "    }",
        "",
        "    final void copyIfNecessary() {",
        "      if (forceCopy) {",
        "        copy();",
        "        forceCopy = false;",
        "      }",
        "    }",
        "",
        "    void copy() {",
        "      impl = impl.copy();",
        "    }",
        "",
        "    @Override",
        "    @CanIgnoreReturnValue",
        "    public Builder<E> add(E element) {",
        "      checkNotNull(element);",
        "      copyIfNecessary();",
        "      impl = impl.add(element);",
        "      return this;",
        "    }",
        "",
        "    @Override",
        "    @CanIgnoreReturnValue",
        "    public Builder<E> add(E... elements) {",
        "      super.add(elements);",
        "      return this;",
        "    }",
        "",
        "    @Override",
        "    @CanIgnoreReturnValue",
        "    public Builder<E> addAll(Iterable<? extends E> elements) {",
        "      super.addAll(elements);",
        "      return this;",
        "    }",
        "",
        "    @Override",
        "    @CanIgnoreReturnValue",
        "    public Builder<E> addAll(Iterator<? extends E> elements) {",
        "      super.addAll(elements);",
        "      return this;",
        "    }",
        "",
        "    Builder<E> combine(Builder<E> other) {",
        "      copyIfNecessary();",
        "      this.impl = this.impl.combine(other.impl);",
        "      return this;",
        "    }",
        "",
        "    @Override",
        "    public ImmutableSet<E> build() {",
        "      forceCopy = true;",
        "      impl = impl.review();",
        "      return impl.build();",
        "    }",
        "  }",
        "",
        "  private abstract static class SetBuilderImpl<E> {",
        "    E[] dedupedElements;",
        "    int distinct;",
        "",
        "    @SuppressWarnings(\"unchecked\")",
        "    SetBuilderImpl(int expectedCapacity) {",
        "      this.dedupedElements = (E[]) new Object[expectedCapacity];",
        "      this.distinct = 0;",
        "    }",
        "",
        "    SetBuilderImpl(SetBuilderImpl<E> toCopy) {",
        "      this.dedupedElements = Arrays.copyOf(toCopy.dedupedElements,"
            + " toCopy.dedupedElements.length);",
        "      this.distinct = toCopy.distinct;",
        "    }",
        "",
        "    private void ensureCapacity(int minCapacity) {",
        "      if (minCapacity > dedupedElements.length) {",
        "        int newCapacity =",
        "            ImmutableCollection.Builder.expandedCapacity(dedupedElements.length,"
            + " minCapacity);",
        "        dedupedElements = Arrays.copyOf(dedupedElements, newCapacity);",
        "      }",
        "    }",
        "",
        "    final void addDedupedElement(E e) {",
        "      ensureCapacity(distinct + 1);",
        "      dedupedElements[distinct++] = e;",
        "    }",
        "",
        "    abstract SetBuilderImpl<E> add(E e);",
        "",
        "    final SetBuilderImpl<E> combine(SetBuilderImpl<E> other) {",
        "      SetBuilderImpl<E> result = this;",
        "      for (int i = 0; i < other.distinct; i++) {",
        "        result = result.add(other.dedupedElements[i]);",
        "      }",
        "      return result;",
        "    }",
        "",
        "    abstract SetBuilderImpl<E> copy();",
        "",
        "    SetBuilderImpl<E> review() {",
        "      return this;",
        "    }",
        "",
        "    abstract ImmutableSet<E> build();",
        "  }",
        "",
        "  static final int MAX_TABLE_SIZE = Ints.MAX_POWER_OF_TWO;",
        "",
        "  private static final double DESIRED_LOAD_FACTOR = 0.7;",
        "",
        "  private static final int CUTOFF = (int) (MAX_TABLE_SIZE * DESIRED_LOAD_FACTOR);",
        "",
        "  @VisibleForTesting",
        "  static int chooseTableSize(int setSize) {",
        "    setSize = Math.max(setSize, 2);",
        "    if (setSize < CUTOFF) {",
        "      int tableSize = Integer.highestOneBit(setSize - 1) << 1;",
        "      while (tableSize * DESIRED_LOAD_FACTOR < setSize) {",
        "        tableSize <<= 1;",
        "      }",
        "      return tableSize;",
        "    }",
        "",
        "    checkArgument(setSize < MAX_TABLE_SIZE, \"collection too large\");",
        "    return MAX_TABLE_SIZE;",
        "  }",
        "",
        "  static final double HASH_FLOODING_FPP = 0.001;",
        "",
        "  static final int MAX_RUN_MULTIPLIER = 13;",
        "",
        "  static boolean hashFloodingDetected(Object[] hashTable) {",
        "    int maxRunBeforeFallback = maxRunBeforeFallback(hashTable.length);",
        "",
        "    int endOfStartRun;",
        "    for (endOfStartRun = 0; endOfStartRun < hashTable.length; ) {",
        "      if (hashTable[endOfStartRun] == null) {",
        "        break;",
        "      }",
        "      endOfStartRun++;",
        "      if (endOfStartRun > maxRunBeforeFallback) {",
        "        return true;",
        "      }",
        "    }",
        "    int startOfEndRun;",
        "    for (startOfEndRun = hashTable.length - 1; startOfEndRun > endOfStartRun;"
            + " startOfEndRun--) {",
        "      if (hashTable[startOfEndRun] == null) {",
        "        break;",
        "      }",
        "      if (endOfStartRun + (hashTable.length - 1 - startOfEndRun) > maxRunBeforeFallback)"
            + " {",
        "        return true;",
        "      }",
        "    }",
        "",
        "    int testBlockSize = maxRunBeforeFallback / 2;",
        "    blockLoop:",
        "    for (int i = endOfStartRun + 1; i + testBlockSize <= startOfEndRun; i +="
            + " testBlockSize) {",
        "      for (int j = 0; j < testBlockSize; j++) {",
        "        if (hashTable[i + j] == null) {",
        "          continue blockLoop;",
        "        }",
        "      }",
        "      return true;",
        "    }",
        "    return false;",
        "  }",
        "",
        "  private static int maxRunBeforeFallback(int tableSize) {",
        "  }",
        "",
        "  private static final class RegularSetBuilderImpl<E> extends SetBuilderImpl<E> {",
        "    private Object[] hashTable;",
        "    private int maxRunBeforeFallback;",
        "    private int expandTableThreshold;",
        "    private int hashCode;",
        "",
        "    RegularSetBuilderImpl(int expectedCapacity) {",
        "      super(expectedCapacity);",
        "      int tableSize = chooseTableSize(expectedCapacity);",
        "      this.hashTable = new Object[tableSize];",
        "      this.maxRunBeforeFallback = maxRunBeforeFallback(tableSize);",
        "      this.expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * tableSize);",
        "    }",
        "",
        "    RegularSetBuilderImpl(RegularSetBuilderImpl<E> toCopy) {",
        "      super(toCopy);",
        "      this.hashTable = Arrays.copyOf(toCopy.hashTable, toCopy.hashTable.length);",
        "      this.maxRunBeforeFallback = toCopy.maxRunBeforeFallback;",
        "      this.expandTableThreshold = toCopy.expandTableThreshold;",
        "      this.hashCode = toCopy.hashCode;",
        "    }",
        "",
        "    void ensureTableCapacity(int minCapacity) {",
        "      if (minCapacity > expandTableThreshold && hashTable.length < MAX_TABLE_SIZE) {",
        "        int newTableSize = hashTable.length * 2;",
        "        hashTable = rebuildHashTable(newTableSize, dedupedElements, distinct);",
        "        maxRunBeforeFallback = maxRunBeforeFallback(newTableSize);",
        "        expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * newTableSize);",
        "      }",
        "    }",
        "",
        "    @Override",
        "    SetBuilderImpl<E> add(E e) {",
        "      checkNotNull(e);",
        "      int eHash = e.hashCode();",
        "      int i0 = Hashing.smear(eHash);",
        "      int mask = hashTable.length - 1;",
        "      for (int i = i0; i - i0 < maxRunBeforeFallback; i++) {",
        "        int index = i & mask;",
        "        Object tableEntry = hashTable[index];",
        "        if (tableEntry == null) {",
        "          addDedupedElement(e);",
        "          hashTable[index] = e;",
        "          hashCode += eHash;",
        "          return this;",
        "          return this;",
        "        }",
        "      }",
        "      return new JdkBackedSetBuilderImpl<E>(this).add(e);",
        "    }",
        "",
        "    @Override",
        "    SetBuilderImpl<E> copy() {",
        "      return new RegularSetBuilderImpl<E>(this);",
        "    }",
        "",
        "    @Override",
        "    SetBuilderImpl<E> review() {",
        "      int targetTableSize = chooseTableSize(distinct);",
        "      if (targetTableSize * 2 < hashTable.length) {",
        "        hashTable = rebuildHashTable(targetTableSize, dedupedElements, distinct);",
        "        maxRunBeforeFallback = maxRunBeforeFallback(targetTableSize);",
        "      }",
        "      return hashFloodingDetected(hashTable) ? new JdkBackedSetBuilderImpl<E>(this) :"
            + " this;",
        "    }",
        "",
        "    @Override",
        "    ImmutableSet<E> build() {",
        "      switch (distinct) {",
        "        case 0:",
        "          return of();",
        "        case 1:",
        "          return of(dedupedElements[0]);",
        "        default:",
        "          Object[] elements =",
        "              (distinct == dedupedElements.length)",
        "                  ? dedupedElements",
        "                  : Arrays.copyOf(dedupedElements, distinct);",
        "          return new RegularImmutableSet<E>(elements, hashCode, hashTable,"
            + " hashTable.length - 1);",
        "      }",
        "    }",
        "  }",
        "",
        "  private static final class JdkBackedSetBuilderImpl<E> extends SetBuilderImpl<E> {",
        "    private final Set<Object> delegate;",
        "",
        "    JdkBackedSetBuilderImpl(SetBuilderImpl<E> toCopy) {",
        "      delegate = Sets.newHashSetWithExpectedSize(distinct);",
        "      for (int i = 0; i < distinct; i++) {",
        "        delegate.add(dedupedElements[i]);",
        "      }",
        "    }",
        "",
        "    @Override",
        "    SetBuilderImpl<E> add(E e) {",
        "      checkNotNull(e);",
        "      if (delegate.add(e)) {",
        "        addDedupedElement(e);",
        "      }",
        "      return this;",
        "    }",
        "",
        "    @Override",
        "    SetBuilderImpl<E> copy() {",
        "      return new JdkBackedSetBuilderImpl<>(this);",
        "    }",
        "",
        "    @Override",
        "    ImmutableSet<E> build() {",
        "      switch (distinct) {",
        "        case 0:",
        "          return of();",
        "        case 1:",
        "          return of(dedupedElements[0]);",
        "        default:",
        "          return new JdkBackedImmutableSet<E>(",
        "              delegate, ImmutableList.asImmutableList(dedupedElements, distinct));",
        "      }",
        "    }",
        "  }",
        "}",
      },
      {
        // all the imports (what we are interested in finding out!)
        "checkArgument",
        "checkNotNull",
        "checkNonnegative",
        "Beta",
        "GwtCompatible",
        "VisibleForTesting",
        "IntMath",
        "Ints",
        "CanIgnoreReturnValue",
        "LazyInit",
        "RetainedWith",
        "Serializable",
        "RoundingMode",
        "Arrays",
        "Collection",
        "EnumSet",
        "Iterator",
        "Set",
        "SortedSet",
        "Spliterator",
        "Consumer",
        "Collector",
        "Nullable",
        // Identifiers that are in the package
        "RegularImmutableAsList",
        "ImmutableCollection",
        "toArray",
        "SingletonImmutableSet",
        "ImmutableAsList",
        "JdkBackedImmutableSet",
        "Hashing",
        "ImmutableList",
        "CollectSpliterators",
        "RegularImmutableSet",
        "CollectCollectors",
        "Sets",
        "ImmutableEnumSet",
        "UnmodifiableIterator",
        // Identifiers that are in the package and resolved through class extension
        "DEFAULT_INITIAL_CAPACITY",
        // Identifiers that are not in the package but resolved through class extension
        "size",
        // Constants
        "Override",
        "Iterable",
        "Math",
        "this",
        "Object",
        "SuppressWarnings",
        "System",
        "super",
        "Integer",
        "SafeVarargs",
        // These come from classes that, while having their parents in the file, could not be
        // safely extended yet due to their parent being a child of an orphan class
        "dedupedElements",
        "addDedupedElement",
        "distinct",
      },
      {
        ClassEntity.named(aSelector("ImmutableSet"))
            .extending(Superclass.unresolved(aSelector("ImmutableCollection")))
            .declaring(
                someIdentifiers(
                    "Builder",
                    "E",
                    "Indexed",
                    "JdkBackedSetBuilderImpl",
                    "RegularSetBuilderImpl",
                    "SerializedForm",
                    "SetBuilderImpl",
                    "<init>",
                    "SPLITERATOR_CHARACTERISTICS",
                    "toImmutableSet",
                    "of",
                    "constructUnknownDuplication",
                    "construct",
                    "copyOf",
                    "copyOfEnumSet",
                    "isHashCodeFast",
                    "equals",
                    "hashCode",
                    "iterator",
                    "asList",
                    "createAsList",
                    "writeReplace",
                    "builder",
                    "builderWithExpectedSize",
                    "rebuildHashTable",
                    "MAX_TABLE_SIZE",
                    "DESIRED_LOAD_FACTOR",
                    "CUTOFF",
                    "chooseTableSize",
                    "HASH_FLOODING_FPP",
                    "MAX_RUN_MULTIPLIER",
                    "hashFloodingDetected",
                    "maxRunBeforeFallback"))
            .build(),
        ClassEntity.named(aSelector("Indexed"))
            .extending(Superclass.unresolved(aSelector("ImmutableSet")))
            .declaring(
                someIdentifiers(
                    "E",
                    "get",
                    "iterator",
                    "spliterator",
                    "forEach",
                    "copyIntoArray",
                    "createAsList"))
            .build(),
        ClassEntity.named(aSelector("SerializedForm"))
            .declaring(someIdentifiers("<init>", "elements", "readResolve", "serialVersionUID"))
            .build(),
        ClassEntity.named(aSelector("Builder"))
            .extending(Superclass.unresolved(aSelector("ImmutableCollection.Builder")))
            .declaring(
                someIdentifiers(
                    "<init>",
                    "E",
                    "impl",
                    "forceCopy",
                    "forceJdk",
                    "copyIfNecessary",
                    "copy",
                    "add",
                    "addAll",
                    "combine",
                    "build"))
            .build(),
        ClassEntity.named(aSelector("SetBuilderImpl"))
            .declaring(
                someIdentifiers(
                    "<init>",
                    "E",
                    "dedupedElements",
                    "distinct",
                    "ensureCapacity",
                    "addDedupedElement",
                    "add",
                    "combine",
                    "copy",
                    "review",
                    "build"))
            .build(),
        ClassEntity.named(aSelector("RegularSetBuilderImpl"))
            .extending(Superclass.unresolved(aSelector("SetBuilderImpl")))
            .declaring(
                someIdentifiers(
                    "<init>",
                    "E",
                    "hashTable",
                    "maxRunBeforeFallback",
                    "expandTableThreshold",
                    "hashCode",
                    "ensureTableCapacity",
                    "add",
                    "copy",
                    "review",
                    "build"))
            .build(),
        ClassEntity.named(aSelector("JdkBackedSetBuilderImpl"))
            .extending(Superclass.unresolved(aSelector("SetBuilderImpl")))
            .declaring(someIdentifiers("<init>", "E", "delegate", "add", "copy", "build"))
            .build(),
        // Anonymous class
        ClassEntity.anonymous()
            .extending(Superclass.unresolved(aSelector("ImmutableAsList")))
            .declaring(someIdentifiers("delegateCollection", "get"))
            .build()
      },
    },
  };

  static Stream<Arguments> dataProvider() {
    ImmutableList.Builder<Arguments> builder = ImmutableList.builder();
    for (Object[][] inputOutput : CASES) {
      String name = (String) inputOutput[0][0];
      String input = String.join("\n", Arrays.stream(inputOutput[1]).toArray(String[]::new)) + "\n";
      Set<Identifier> expected =
          Sets.newHashSet(
              Arrays.stream(inputOutput[2])
                  .map(String.class::cast)
                  .map(Identifier::new)
                  .toArray(Identifier[]::new));
      ClassEntity[] expectedClasses = Arrays.stream(inputOutput[3]).toArray(ClassEntity[]::new);
      builder.add(Arguments.of(name, input, expected, expectedClasses));
    }

    return builder.build().stream();
  }

  private static Set<Identifier> allUnresolvedIn(ParsedFile file) {
    // Do a traversal of orphans to force local resolution
    var traverser = file.orphans().traverse();
    while (traverser.next() != null) {}

    return file.unresolved();
  }

  @ParameterizedTest(name = "{0}")
  @MethodSource("dataProvider")
  public void testParseFindsUnresolved(
      String name, String input, Set<Identifier> expected, ClassEntity[] expectedClasses)
      throws Exception {
    Parser parser = new Parser();
    ParsedFile got = null;
    try {
      got = parser.parse(Paths.get(name), input, null).get();
    } catch (ImporterException e) {
      for (ImporterException.ImporterDiagnostic d : e.diagnostics()) {
        System.out.println(d);
      }
      fail();
    }
    // Scope.debugPrintScopeTree(got.topScope(), System.out);

    assertWithMessage("Invalid output for " + name)
        .that(allUnresolvedIn(got))
        .containsExactlyElementsIn(expected);
    if (expectedClasses.length > 0) {
      assertWithMessage("Invalid output for " + name)
          .about(StreamSubject.streams())
          .that(got.allClasses())
          .containsExactly(expectedClasses);
    }
  }
}
